//----------------------------------------------------------------------------------- 
// Disclaimer:
//
// This software and documentation (the "Software") were developed at the 
// Food and Drug Administration (FDA) by employees of the Federal Government 
// in the course of their official duties. Pursuant to Title 17, Section 105 
// of the United States Code, this work is not subject to copyright protection 
// and is in the public domain. Permission is hereby granted, free of charge, 
// to any person obtaining a copy of the Software, to deal in the Software 
// without restriction, including without limitation the rights to use, copy, 
// modify, merge, publish, distribute, sublicense, or sell copies of the 
// Software or derivatives, and to permit persons to whom the Software 
// is furnished to do so. FDA assumes no responsibility whatsoever for 
// use by other parties of the Software, its source code, documentation or 
// compiled executables, and makes no guarantees, expressed or implied, 
// about its quality, reliability, or any other characteristic.   
// Further, use of this code in no way implies endorsement by the FDA 
// or confers any advantage in regulatory decisions.  
// Although this software can be redistributed and/or modified freely, 
// we ask that any derivative works bear some notice that they are derived from it, 
// and any modified versions bear some notice that they have been modified.
//
//----------------------------------------------------------------------------------- 
// Authors:
//
// Wei-Chung Cheng, Chih-Lei Wu and Aldo Badano
// Division of Imaging and Applied Mathematics
// Office of Science and Engineering Labs
// Center for Devices and Radiological Health
// Food and Drug Administration
// E-mail: Wei-Chung.Cheng@fda.hhs.gov
//
//----------------------------------------------------------------------------------- 
// Overview:
//
// The Virtual Display Color Processor (VDCP) is a hardware tool for monitoring 
// the pixel data sent from the computer to the display via the Digital Video 
// Interface (DVI) cable. The VDCP is a circuit board to be connected between 
// the DVI cable and the DVI port. The VDCP circuit retrieves the red, green, 
// and blue subpixel values of the target pixel and then show the subpixel values 
// on the display. The hardware portion of VDCP consists of a field programmable 
// gate array (FPGA) board (Cyclone III QB3, Altera) and a DVI daughter board 
// (DVI-HSMC, Terasic). The software portion of VDCP, as described in this document, 
// was designed with the Verilog hardware description language.
//
//----------------------------------------------------------------------------------- 
// Functions:
//
// By pressing a button, it switches between 8 lookup tables for emulating various 
// tone reproduction curves. It shows the RGB values of a center pixel for the 
// last 4 frames. The pixel location is centered enough to be included in the test 
// patterns generated by the color calibration kit but not underneath the sensor 
// to hinder the measurement. The color processor writes the 256-byte EDID 
// information into the DVI receiver such that the computer can retrieve the 
// information of available resolutions.
//
//
//--------------------------------------------------------------------
// Revision:
//
// 12/4/2013        
//--------------------------------------------------------------------  

module VDCP (	
							reset_n,
							DVI_RX_CLK,
							DVI_RX_DE,
							DVI_RX_HS,
							DVI_RX_VS,
							DVI_RX_D,
							pll_100K,
							rx_clk,
							rx_data, 
							rx_de,
							rx_hs,
							rx_vs
						);

input					reset_n;
input					DVI_RX_CLK;
input					DVI_RX_DE;	
input					DVI_RX_HS;
input					DVI_RX_VS;
input		[23:0]	DVI_RX_D;	
input					pll_100K;					
output 				rx_clk;
output	[23:0]	rx_data;

//
// previous DE, HS, and VS signals
//
output				rx_de;
output				rx_hs;
output				rx_vs;


//
// use the same naming convention as the factory demo code
//
wire					reset_n;
wire					DVI_RX_CLK;
wire					DVI_RX_DE;	
wire					DVI_RX_HS;
wire					DVI_RX_VS;
wire		[23:0]	DVI_RX_D;	
wire					pll_100K;					
wire 					rx_clk;
reg		[23:0]	rx_data;
reg					rx_de;
reg					rx_hs;
reg					rx_vs;

assign rx_clk = ~DVI_RX_CLK;


//
// X-Y position of the current pixel
//
reg	[12:0]	mypixel_x;
reg	[12:0]	mypixel_y;

//
// frame number mod 4
//
reg 	[1:0] 	frameno;

//
// undergoing V-sync if ==1
//
reg				in_vsync;

//
// X-Y position of the target pixel (cursor)
//
parameter target_x = 640;
parameter target_y = 512;

//
// captured RGB values of the target pixel
//
reg	[7:0]		targetr;
reg	[7:0]		targetg;
reg	[7:0]		targetb;

//
// variables for converting binary into decimal (BCD)
// for output
//
wire 	[3:0] 	targetrd0 = targetr % 10;
wire 	[3:0] 	targetrd1 = (targetr/10) % 10;
wire 	[3:0] 	targetrd2 = (targetr/100) % 10;
wire 	[3:0] 	targetgd0 = targetg % 10;
wire 	[3:0] 	targetgd1 = (targetg/10) % 10;
wire 	[3:0] 	targetgd2 = (targetg/100) % 10;
wire 	[3:0] 	targetbd0 = targetb % 10;
wire 	[3:0] 	targetbd1 = (targetb/10) % 10;
wire 	[3:0] 	targetbd2 = (targetb/100) % 10;

//
// font bitmap of numberic characters from '0' to '9'
// 
reg [7:0] char0 [0:79];
 

always@(posedge rx_clk or negedge reset_n) // OCK_INV=GND, latches output data on falling edge
begin
	if (!reset_n)
	begin
		rx_data <= {8'h00, 8'h00, 8'h00};
		rx_de <= 1'b0;
		rx_hs <= 1'b1;
		rx_vs <= 1'b1;
	end
	else
	begin

		//
		// check for every clock
		//
		if (DVI_RX_DE==1)					// if valid pixel data then advance X
		begin
			mypixel_x = mypixel_x + 1;
			in_vsync = 0;
		end

		else if (rx_de==1)				// more than one DE negative -> H-sync -> next scan line 
		begin
			mypixel_x = 0;					// reset X
			mypixel_y = mypixel_y + 1 ;// advance Y
			if (mypixel_y == 1)			// if it is a new frame
				frameno = frameno + 1;	// advance frame number mod 4
		end

		else if (DVI_RX_VS==1)			// 1280x1024: VS==1 -> V-sync; 1680x1050: VS==0
		begin
			mypixel_x = 0;
			mypixel_y = 0;
		end

		//
		// check whether the target pixel is scanned
		// 
		if (mypixel_x==target_x && mypixel_y==target_y)
		begin
			targetr = DVI_RX_D[23:16];	// grab Red subpixel
			targetg = DVI_RX_D[15:8];	// grab Green subpixel
			targetb = DVI_RX_D[7:0];	// grab Blue subpixel
			rx_data = {DVI_RX_D[23:16], DVI_RX_D[15:8], DVI_RX_D[7:0]};	// combine the values
		end
		
		//
		// check whether the pixel box is scanned
		//
		else if (
			(mypixel_x==target_x-1 && mypixel_y==target_y-1) ||
			(mypixel_x==target_x-1 && mypixel_y==target_y+1) ||
			(mypixel_x==target_x+1 && mypixel_y==target_y-1) ||
			(mypixel_x==target_x+1 && mypixel_y==target_y+1) ||
			(mypixel_x==target_x-1 && mypixel_y==target_y) ||
			(mypixel_x==target_x+1 && mypixel_y==target_y) ||
			(mypixel_x==target_x && mypixel_y==target_y-1) ||
			(mypixel_x==target_x && mypixel_y==target_y+1) 
			)
		begin
			// reverse the pixel color to form a "box" surrounding the target pixel
			rx_data = {~DVI_RX_D[23:16], ~DVI_RX_D[15:8], ~DVI_RX_D[7:0]};
		end
		else
		begin
			//
			// show the RGB values on screen
			//
			
			//
			// Red subpixel value shown on row [8..15]
			//
			// Hundreds digit
			if ((mypixel_y>=8 && mypixel_y<=15) && (mypixel_x>=32*frameno+8 && mypixel_x<=32*frameno+15))
			begin
				// mask to get the "mypixel_y"-th bit from the bitmap
				if ((char0[(targetrd2<<3)+(mypixel_y&7)] & (8'h80 >> (mypixel_x & 7))) != 0)
					// paint with red color
					rx_data = {8'hff, 8'hf0, 8'hf0};
				else
					// otherwise use the original color 
					rx_data = {DVI_RX_D[23:16], DVI_RX_D[15:8], DVI_RX_D[7:0]};
			end
			// Tens digit
			else if ((mypixel_y>=8 && mypixel_y<=15) && (mypixel_x>=32*frameno+16 && mypixel_x<=32*frameno+23))
			begin
				// mask to get the "mypixel_y"-th bit from the bitmap
				if ((char0[(targetrd1<<3)+(mypixel_y&7)] & (8'h80 >> (mypixel_x & 7))) != 0)
					// paint with red color
					rx_data = {8'hff, 8'hf0, 8'hf0};
				else
					// otherwise use the original color 
					rx_data = {DVI_RX_D[23:16], DVI_RX_D[15:8], DVI_RX_D[7:0]};
			end
			// Ones digit
			else if ((mypixel_y>=8 && mypixel_y<=15) && (mypixel_x>=32*frameno+24 && mypixel_x<=32*frameno+31))
			begin
				// mask to get the "mypixel_y"-th bit from the bitmap
				if ((char0[(targetrd0<<3)+(mypixel_y&7)] & (8'h80 >> (mypixel_x & 7))) != 0)
					// paint with red color
					rx_data = {8'hff, 8'hf0, 8'hf0};
				else
					// otherwise use the original color 
					rx_data = {DVI_RX_D[23:16], DVI_RX_D[15:8], DVI_RX_D[7:0]};
			end

			//
			// Green subpixel value shown on row [24..31]
			//
			// Hundreds digit
			else if ((mypixel_y>=24 && mypixel_y<=31) && (mypixel_x>=32*frameno+8 && mypixel_x<=32*frameno+15))
			begin
				if ((char0[(targetgd2<<3)+(mypixel_y&7)] & (8'h80 >> (mypixel_x & 7))) != 0)
					// paint with green color
					rx_data = {8'hf0, 8'hff, 8'hf0};
				else
					// otherwise use the original color 
					rx_data = {DVI_RX_D[23:16], DVI_RX_D[15:8], DVI_RX_D[7:0]};
			end
			// Tens digit
			else if ((mypixel_y>=24 && mypixel_y<=31) && (mypixel_x>=32*frameno+16 && mypixel_x<=32*frameno+23))
			begin
				if ((char0[(targetgd1<<3)+(mypixel_y&7)] & (8'h80 >> (mypixel_x & 7))) != 0)
					// paint with green color
					rx_data = {8'hf0, 8'hff, 8'hf0};
				else
					// otherwise use the original color 
					rx_data = {DVI_RX_D[23:16], DVI_RX_D[15:8], DVI_RX_D[7:0]};
			end
			// Ones digit
			else if ((mypixel_y>=24 && mypixel_y<=31) && (mypixel_x>=32*frameno+24 && mypixel_x<=32*frameno+31))
			begin
				if ((char0[(targetgd0<<3)+(mypixel_y&7)] & (8'h80 >> (mypixel_x & 7))) != 0)
					// paint with green color
					rx_data = {8'hf0, 8'hff, 8'hf0};
				else
					// otherwise use the original color 
					rx_data = {DVI_RX_D[23:16], DVI_RX_D[15:8], DVI_RX_D[7:0]};
			end

			//
			// Blue subpixel value shown on row [40..47]
			//
			// Hundreds digit
			else if ((mypixel_y>=40 && mypixel_y<=47) && (mypixel_x>=32*frameno+8 && mypixel_x<=32*frameno+15))
			begin
				if ((char0[(targetbd2<<3)+(mypixel_y&7)] & (8'h80 >> (mypixel_x & 7))) != 0)
					// paint with blue color
					rx_data = {8'hf0, 8'hf0, 8'hff};
				else
					// otherwise use the original color 
					rx_data = {DVI_RX_D[23:16], DVI_RX_D[15:8], DVI_RX_D[7:0]};
			end
			// Tens digit
			else if ((mypixel_y>=40 && mypixel_y<=47) && (mypixel_x>=32*frameno+16 && mypixel_x<=32*frameno+23))
			begin
				if ((char0[(targetbd1<<3)+(mypixel_y&7)] & (8'h80 >> (mypixel_x & 7))) != 0)
					// paint with blue color
					rx_data = {8'hf0, 8'hf0, 8'hff};
				else
					// otherwise use the original color 
					rx_data = {DVI_RX_D[23:16], DVI_RX_D[15:8], DVI_RX_D[7:0]};
			end
			// Ones digit
			else if ((mypixel_y>=40 && mypixel_y<=47) && (mypixel_x>=32*frameno+24 && mypixel_x<=32*frameno+31))
			begin
				if ((char0[(targetbd0<<3)+(mypixel_y&7)] & (8'h80 >> (mypixel_x & 7))) != 0)
					// paint with blue color
					rx_data = {8'hf0, 8'hf0, 8'hff};
				else
					// otherwise use the original color 
					rx_data = {DVI_RX_D[23:16], DVI_RX_D[15:8], DVI_RX_D[7:0]};
			end

			//
			// outside the window that shows the subpixel values
			//
			else
				// keep the original color 
				rx_data = {DVI_RX_D[23:16], DVI_RX_D[15:8], DVI_RX_D[7:0]};
		end
	
		//
		// refresh 
		//
		rx_de <= DVI_RX_DE;
		rx_hs <= DVI_RX_HS;
		rx_vs <= DVI_RX_VS;
	end
	
end	


//
// 8x8 bitmap for font of '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'
// 1=pixel on, 0=pixel off
// 
always @(posedge pll_100K)
	begin

		char0[0] = 8'b01111100;
		char0[1] = 8'b10000010;
		char0[2] = 8'b10000010;
		char0[3] = 8'b10000010;
		char0[4] = 8'b10000010;
		char0[5] = 8'b10000010;
		char0[6] = 8'b10000010;
		char0[7] = 8'b01111100;

		char0[8] =  8'b00010000;
		char0[9] =  8'b00010000;
		char0[10] = 8'b00010000;
		char0[11] = 8'b00010000;
		char0[12] = 8'b00010000;
		char0[13] = 8'b00010000;
		char0[14] = 8'b00010000;
		char0[15] = 8'b00010000;

		char0[16] = 8'b01111100;
		char0[17] = 8'b10000010;
		char0[18] = 8'b00000010;
		char0[19] = 8'b00000010;
		char0[20] = 8'b01111100;
		char0[21] = 8'b10000000;
		char0[22] = 8'b10000000;
		char0[23] = 8'b11111110;

		char0[24] = 8'b01111100;
		char0[25] = 8'b10000010;
		char0[26] = 8'b00000010;
		char0[27] = 8'b01111100;
		char0[28] = 8'b00000010;
		char0[29] = 8'b00000010;
		char0[30] = 8'b10000010;
		char0[31] = 8'b01111100;

		char0[32] = 8'b00011000;
		char0[33] = 8'b00101000;
		char0[34] = 8'b01001000;
		char0[35] = 8'b10001000;
		char0[36] = 8'b10001000;
		char0[37] = 8'b11111110;
		char0[38] = 8'b00001000;
		char0[39] = 8'b00001000;

		char0[40] = 8'b11111110;
		char0[41] = 8'b10000000;
		char0[42] = 8'b10000000;
		char0[43] = 8'b11111100;
		char0[44] = 8'b00000010;
		char0[45] = 8'b00000010;
		char0[46] = 8'b00000010;
		char0[47] = 8'b11111100;

		char0[48] = 8'b00010000;
		char0[49] = 8'b00100000;
		char0[50] = 8'b01000000;
		char0[51] = 8'b10111100;
		char0[52] = 8'b11000010;
		char0[53] = 8'b10000010;
		char0[54] = 8'b10000010;
		char0[55] = 8'b01111100;

		char0[56] = 8'b11111110;
		char0[57] = 8'b00000010;
		char0[58] = 8'b00000100;
		char0[59] = 8'b00001000;
		char0[60] = 8'b00010000;
		char0[61] = 8'b00010000;
		char0[62] = 8'b00010000;
		char0[63] = 8'b00010000;

		char0[64] = 8'b01111100;
		char0[65] = 8'b10000010;
		char0[66] = 8'b10000010;
		char0[67] = 8'b01111100;
		char0[68] = 8'b10000010;
		char0[69] = 8'b10000010;
		char0[70] = 8'b10000010;
		char0[71] = 8'b01111100;

		char0[72] = 8'b01111100;
		char0[73] = 8'b10000010;
		char0[74] = 8'b10000010;
		char0[75] = 8'b10000010;
		char0[76] = 8'b01111110;
		char0[77] = 8'b00000100;
		char0[78] = 8'b00001000;
		char0[79] = 8'b00010000;

end

endmodule